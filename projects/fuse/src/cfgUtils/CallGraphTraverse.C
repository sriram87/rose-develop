#ifndef CALL_GRAPH_TRAVERSE_C
#define CALL_GRAPH_TRAVERSE_C

#include "sage3basic.h"
#include "CallGraphTraverse.h"
#include "cfgUtils.h"
#include "sageInterface.h"
#include "midend/programAnalysis/CallGraphAnalysis/CallGraph.h"
using namespace SageInterface;

#include <set>
using namespace std;

namespace fuse {
// Points to the object that stores the entire class hierarchy of all types
ClassHierarchyWrapper* classHierarchy=NULL;

// Initializes and returns the ClassHierarchyGraph
static ClassHierarchyWrapper* CHG() {
  if(classHierarchy==NULL) {
    classHierarchy = new ClassHierarchyWrapper(getProject());
    ROSE_ASSERT(classHierarchy);
  }
  return classHierarchy;
}

  
/****************************
 ********* Function *********
 ****************************/
Function::Function()
{
  decl=NULL;
}
 
Function::Function(string name)
{
  //printf("Function::Function(string name) this=0x%x\n", this);
  //def = NULL;

  Rose_STL_Container<SgNode*> functions = NodeQuery::querySubTree(SageInterface::getProject(), V_SgFunctionDeclaration);
  for (Rose_STL_Container<SgNode*>::const_iterator it = functions.begin(); it != functions.end(); it++)
  {
    assert(isSgFunctionDeclaration(*it));

    if(isSgFunctionDeclaration(*it)->get_name().getString() == name)
    {
      // decl will be initialized to the defining declaration of this function or 
      // the first non-defining declaratio,n if there is no definition
      decl = getCanonicalDecl(isSgFunctionDeclaration(*it));
      break;
      /*decls.insert(isSgFunctionDeclaration(*it));
      if(isSgFunctionDeclaration(*it)->get_definition())
      {
        // save the current function's definition inside def
        // ensure that either def has not been set yet or that there is a unique definition
        if(def==NULL)
          def = isSgFunctionDeclaration(*it)->get_definition();
        else
          assert(def == isSgFunctionDeclaration(*it)->get_definition());
      }*/
    }
  }

  // every function must have at least one declaration
  //assert(decls.size()>0);
  assert(decl);
}

Function::Function(SgFunctionDeclaration* sample)
{
  //printf("Function::Function(SgFunctionDeclaration* sample) this=0x%x\n", this);
  init(sample);
}

Function::Function(SgFunctionDefinition* sample)
{
  //printf("Function::Function(SgFunctionDefinition* sample) this=0x%x\n", this);
  init(sample->get_declaration());

  // ensure that the definition found by init() is the same as what got passed in here
  //assert(def == sample);
}

Function::Function(SgFunctionCallExp* funcCall)
{
  //dbg << "Function::Function("<<SgNode2Str(funcCall)<<")"<<endl;
  //assert(isSgFunctionRefExp(funcCall->get_function()));
  // If the call's referent is known, initialize based on its declaration
  if(isSgFunctionRefExp(funcCall->get_function())) {
    assert(isSgFunctionRefExp(funcCall->get_function())->get_symbol());
    assert(isSgFunctionRefExp(funcCall->get_function())->get_symbol()->get_declaration());
    init(isSgFunctionRefExp(funcCall->get_function())->get_symbol()->get_declaration());
  } else if(isSgDotExp(funcCall->get_function())) {
    SgExpression *rhs = isSgDotExp(funcCall->get_function())->get_rhs_operand();
    while(isSgDotExp(rhs)) rhs = isSgDotExp(rhs)->get_rhs_operand();
    if(isSgMemberFunctionRefExp(rhs)) {
      assert(isSgMemberFunctionRefExp(rhs)->get_symbol());
      assert(isSgMemberFunctionRefExp(rhs)->get_symbol()->get_declaration());
      init(isSgMemberFunctionRefExp(rhs)->get_symbol()->get_declaration());
    } else
      init(NULL);
  }
  // Otherwise, set the function to NULL
  else
    init(NULL);
}

Function::Function(SgFunctionParameterList* params) {
  init(SageInterface::getEnclosingFunctionDeclaration(params));
}

class NoSymbolExistsAttribute : public AstAttribute {
  public:
virtual AstAttribute::OwnershipPolicy getOwnershipPolicy() const ROSE_OVERRIDE {
  return CONTAINER_OWNERSHIP;
}

  string toString() { return "NoSymbolExistsAttribute"; }
};

void Function::init(SgFunctionDeclaration* sample)
{
  //SgName mangledName = sample->get_mangled_name();
  //def = NULL;

  //printf("Function::init() name=%s=%s\n", this, sample->get_name().str(), mangledName.str());

  // decl will be initialized to the defining declaration or the first non-defining declaration if there is no definition
  if(sample)
    decl = getCanonicalDecl(sample);
  else
    decl = NULL;

  // If this function has no definition or the definition was added by 
  // the syntactic analysis and normally it does not have a definition
  if(!decl || !decl->get_definition() || decl->get_definition()->attributeExists("fuse:UnknownSideEffects")) {
    // Add annotations to the function's parameters to make it clear to the syntactic analysis that
    // the SgInitializedNames of these parameters do not have symbols
    if(decl) {
      SgFunctionParameterList* params = get_params();
      for(SgInitializedNamePtrList::iterator p=params->get_args().begin(); p!=params->get_args().end(); p++)
        (*p)->setAttribute("fuse:NoSymbolExistsAttribute", new NoSymbolExistsAttribute());
    }
  }
  
  // insert the sample declaration into decls, in case this is a name-less function declaration (i.e. a function pointer)
  // which won't show up in an AST query
  //decls.insert(sample);

  /*Rose_STL_Container<SgNode*> functions = NodeQuery::querySubTree(cfgUtils::project, V_SgFunctionDeclaration);
  for (Rose_STL_Container<SgNode*>::const_iterator it = functions.begin(); it != functions.end(); it++)
  {
    assert(isSgFunctionDeclaration(*it));

    if(isSgFunctionDeclaration(*it)->get_mangled_name() == mangledName)
    {
      decls.insert(isSgFunctionDeclaration(*it));
      if(isSgFunctionDeclaration(*it)->get_definition())
      {
  // save the current function's definition inside def
  // ensure that either def has not been set yet or that there is a unique definition
  if(def==NULL)
    def = isSgFunctionDeclaration(*it)->get_definition();
  else
    assert(def == isSgFunctionDeclaration(*it)->get_definition());
      }
    }
  }
  //decls.insert(sample);
  //def = sample->get_definition();

  //printf("Function::init() this: 0x%x, name=%s *(decls.begin())=0x%x  decls.size()=%d def=0x%x\n", this, get_name().str(), *(decls.begin()), decls.size(), def);
  //printf("Function::init() this: 0x%x, name=%s decls.size()=%d def=0x%x\n", this, get_name().str(), decls.size(), def);

  // every function must have at least one declaration
  assert(decls.size()>0);*/
}

Function::Function(const Function &that)
{
  //printf("Function::Function(const Function &that) this=0x%x\n", this);
  /*def = that.def;
  for(set<SgFunctionDeclaration*>::const_iterator it = that.decls.begin(); it!=that.decls.end(); it++)
  {       //printf("      declaration: 0x%x\n", *it);
    decls.insert(*it);
  }*/
  decl = that.decl;
}

Function::Function(const Function *that)
{
  //printf("Function::Function(const Function &that) this=0x%x\n", this);
  /*def = that.def;
  for(set<SgFunctionDeclaration*>::const_iterator it = that.decls.begin(); it!=that.decls.end(); it++)
  {       //printf("      declaration: 0x%x\n", *it);
    decls.insert(*it);
  }*/
  decl = that->decl;
}

// Returns whether the Function that this object refers to is statically known 
bool Function::isKnown() const {
  return decl!=NULL;
}

SgFunctionDeclaration* Function::getCanonicalDecl(SgFunctionDeclaration* sampleDecl)
{
  assert(sampleDecl);
  SgFunctionDeclaration* canonicalDecl = NULL;

  if(sampleDecl->get_definingDeclaration())
    canonicalDecl = isSgFunctionDeclaration(sampleDecl->get_definingDeclaration());
  else
    canonicalDecl = isSgFunctionDeclaration(sampleDecl->get_firstNondefiningDeclaration());
  assert(canonicalDecl);

  return canonicalDecl;
}

bool Function::eq(const Function &that) const
{
  /*printf("Function::eq() %s  that=%s\n", get_name().str(), that.get_name().str());

  printf("         (def != that.def) = %d\n", (def != that.def));
  if(def != that.def) return false;

  // check that that's set of declarations is a subset of this's set of declarations
  for(set<SgFunctionDeclaration*>::const_iterator it = that.decls.begin(); it!=that.decls.end(); it++)
  {
    printf("         (decls.find(*it) == decls.end()) = %d\n", (decls.find(*it) == decls.end()));
    if(decls.find(*it) == decls.end()) return false;
  }

  // check that this's set of declarations is a subset of that's set of declarations
  for(set<SgFunctionDeclaration*>::iterator it = decls.begin(); it!=decls.end(); it++)
  {
    printf("         (that.decls.find(*it) == that.decls.end()) = %d\n", (that.decls.find(*it) == that.decls.end()));
    if(that.decls.find(*it) == that.decls.end()) return false;
  }*/
  //dbg << const_cast<Function*>(this)->str() << " <eq> "<<const_cast<Function&>(that).str()<<" : "<<!(decl != that.decl)<<endl;
  if(decl != that.decl) return false;

  //printf("         Equal\n");
  return true;
}

bool Function::operator == (const Function &that) const
{
  return eq(that);
}

bool Function::operator != (const Function &that) const
{
  return !(*this == that);
}


bool Function::lessThan(const Function &that) const
{
  //dbg << const_cast<Function*>(this)->str() << " <lessThan> "<<const_cast<Function&>(that).str()<<" : "<<(decl < that.decl)<<endl;
  
  // compare the declarations, since every Function object must have a unique canonical declaration
  return decl < that.decl;
  
  /*// if either object has a definition, compare those
  if(def != that.def) return def < that.def;
    
  // if not, let the function with fewer declarations be smaller
  if(decls.size() < that.decls.size()) return true;
    
  // if both functions have the same number of declarations, compare the declarations themselves
  set<SgFunctionDeclaration*>::iterator itThis;
  set<SgFunctionDeclaration*>::const_iterator itThat;
  for(itThis = decls.begin(), itThat = that.decls.begin(); 
      itThis!=decls.end() && itThat!=that.decls.end();
      itThis++, itThat++)
    if(*itThis != *itThat) return *itThis < *itThat;
  
  // ensure that both lists of declarations are finished
  assert(itThis==decls.end() && itThat==that.decls.end());
  
  // clearly, these functions are equal
  return false;*/
}
bool Function::operator < (const Function &that) const
{ return lessThan(that); }
bool Function::operator > (const Function &that) const
{ return !((*this) < that) && ((*this) != that); }
bool Function::operator <= (const Function &that) const
{ return ((*this) < that) || ((*this) == that); }
bool Function::operator >= (const Function &that) const
{ return !((*this) < that); }

SgName Function::get_name() const
{
  // every function must have at least one declaration
  /*assert(*(decls.begin()));

//printf("Function::get_name() this: 0x%x, *(decls.begin())=0x%x  decls.size()=%d def=0x%x\n", this, *(decls.begin()), decls.size(), def);
  return (*(decls.begin()))->get_name();*/
  if(decl)
    return decl->get_name();
  else
    return "";
}

// returns this function's definition or NULL of it does not have one
SgFunctionDefinition* Function::get_definition() const
{
  //return def;
  if(decl)
    return decl->get_definition();
  else
    return NULL;
}

// returns one of this function's declarations. it is guaranteed to be the same each time get_declaration is called
SgFunctionDeclaration* Function::get_declaration() const
{
  //return *(decls.begin());
  return decl;
}

// Returns one of function's defining declaration
SgFunctionDeclaration* Function::get_definingDeclaration() const
{
  //return *(decls.begin());
  return isSgFunctionDeclaration(decl->get_definingDeclaration());
}

// returns the file_info of the definition or one of the declarations if there is no definition
Sg_File_Info* Function::get_file_info() const
{
  /*
  // every function must have at least one declaration
  assert(*(decls.begin()));
  
  if(def) return def->get_file_info();
  else return (*(decls.begin()))->get_file_info();*/
  if(decl)
    return decl->get_file_info();
  else
    return NULL;
}

// Returns the parameters of this function if it is known and NULL if it is not
SgInitializedNamePtrList* Function::get_args() const
{
  if(decl)
    return &(get_declaration()->get_args());
  else
    return NULL;
}

// Returns the parameters of this function if it is known and NULL if it is not
SgFunctionParameterList* Function::get_params() const
{
  if(decl)
    return get_declaration()->get_parameterList();
  else
    return NULL;
}

// Returns the function's type if it is known and NULL if it is not
SgFunctionType* Function::get_type() const
{
  if(decl)
    return get_declaration()->get_type();
  else
    return NULL;
}

// Returns the Function object that refers to the function that contains the given SgNode
Function Function::getEnclosingFunction(SgNode* n, bool includingSelf)
{
  SgFunctionDefinition* def = SageInterface::getEnclosingFunctionDefinition(n, includingSelf);
  if(def) return Function(def);
  else {
    SgFunctionDeclaration* decl = SageInterface::getEnclosingFunctionDeclaration(n, includingSelf);
    assert(decl);
    return Function(decl);
  }
}

string Function::str(string indent) const
{
  ostringstream oss;
  oss << get_name().getString()<<"(";
  SgInitializedNamePtrList* params = get_args();
  if(params) {
    for(SgInitializedNamePtrList::iterator in=params->begin(); in!=params->end(); in++) {
      if(in!=params->begin()) oss << ", ";
      oss << (*in)->get_name().getString();
    }
  }
  oss << ")";
  return oss.str();
}

// Returns the set of functions that the given SgFunctionCallExp may refer to
set<Function> Function::getCallees(SgFunctionCallExp* call) {
  Rose_STL_Container<SgFunctionDeclaration*> calleeList;
  CallTargetSet::getDeclarationsForExpression(call, CHG(), calleeList);
  set<Function> callees;
  for(Rose_STL_Container<SgFunctionDeclaration*>::iterator c=calleeList.begin(); c!=calleeList.end(); c++)
    callees.insert(Function(*c));
  return callees;
}

/******************************
 ********* CGFunction *********
 ******************************/

CGFunction::CGFunction(string name, SgIncidenceDirectedGraph* graph) : Function(name)
{
  this->graph = graph;
  initCGNodes();
}

CGFunction::CGFunction(SgFunctionDeclaration* sample, SgIncidenceDirectedGraph* graph) : Function(sample)
{
  this->graph = graph;
  initCGNodes();
}

CGFunction::CGFunction(SgGraphNode* sample, SgIncidenceDirectedGraph* graph) : Function(isSgFunctionDeclaration(sample->get_SgNode()))
{
  assert(isSgFunctionDeclaration(sample->get_SgNode()));
  
  this->graph = graph;
  initCGNodes();
}

CGFunction::CGFunction(const CGFunction &that) : Function(that)
{
  this->graph = that.graph;

  // copy cgNodes from that to this
  for(set<SgGraphNode*>::iterator it = that.cgNodes.begin(); it!=that.cgNodes.end(); it++)
    cgNodes.insert(*it);
}

CGFunction::CGFunction(const CGFunction *that) : Function(that)
{
  this->graph = that->graph;

  // copy cgNodes from that to this
  for(set<SgGraphNode*>::iterator it = that->cgNodes.begin(); it!=that->cgNodes.end(); it++)
    cgNodes.insert(*it);
}

// initializes the cgNodes set
void CGFunction::initCGNodes()
{
  set<SgGraphNode *> nodes = graph->computeNodeSet();
  for(set<SgGraphNode*>::iterator itn = nodes.begin(); itn != nodes.end(); itn++) {
    SgNode* n = (*itn)->get_SgNode();
    assert(isSgFunctionDeclaration(n));
    
    SgFunctionDeclaration* cfgDecl = getCanonicalDecl(isSgFunctionDeclaration(n));

    /*// if this declaration is in the list of known declarations for this function
    if(decls.find(decl) != decls.end())*/
    // if the given SgGraphNode refers to this function
    if(cfgDecl == decl)
      cgNodes.insert(*itn);
  }
}

bool CGFunction::operator == (const CGFunction &that) const
{
  if(!this->Function::eq(that)) return false;
    
  // check that that's set of SgGraphNodes is a subset of this's set of SgGraphNodes
  for(set<SgGraphNode*>::const_iterator it = that.cgNodes.begin(); it!=that.cgNodes.end(); it++)
    if(cgNodes.find(*it) == cgNodes.end()) return false;
  
  // check that this's set of SgGraphNodes is a subset of that's set of SgGraphNodes
  for(set<SgGraphNode*>::iterator it = cgNodes.begin(); it!=cgNodes.end(); it++)
    if(that.cgNodes.find(*it) == that.cgNodes.end()) return false;
  
  
  printf("CGFunction::operator == returning true\n");
  return true;
}

bool CGFunction::operator != (const CGFunction &that) const
{
  return !(*this == that);
}

bool CGFunction::operator < (const CGFunction &that) const
{ return Function::lessThan(that); }
bool CGFunction::operator > (const CGFunction &that) const
{ return !((*this) < that) && ((*this) != that); }
bool CGFunction::operator <= (const CGFunction &that) const
{ return ((*this) < that) || ((*this) == that); }
bool CGFunction::operator >= (const CGFunction &that) const
{ return !((*this) < that); }

/****************************************
 ********* CGFunction::iterator *********
 ****************************************/

CGFunction::iterator::iterator()
{
  finished = true;
}

CGFunction::iterator::iterator(const CGFunction* const func, direction dir)
{
  this->func = func;
  this->dir = dir;

  finished=false;

  //dbg << "CGFunction::iterator::iterator(func="<<func->str()<<", direction="<<(dir==fw?"fw":"bw")<<endl;
  // Start itn at the first node in cgNodes and keep walking through the cgNodes until we find one that has edges
  itn = func->cgNodes.begin();
  while(itn != func->cgNodes.end()) {
    if(dir == fw) edges = func->graph->computeEdgeSetOut(*itn);
    else          edges = func->graph->computeEdgeSetIn(*itn);
  
    if(edges.size()>0) break;
    itn++;
  }
  
  // If the current cgNode has edges, set ite to the first one
  if(itn != func->cgNodes.end()) {
    ite = edges.begin();
  
    /*dbg << "edges="<<endl;
    indent(1,1);
    for(set<SgDirectedGraphEdge*>::iterator e=edges.begin(); e!=edges.end(); e++) {
      SgGraphNode* target = (dir == fw ? (*e)->get_to() : (*e)->get_from());
      if(target) {
        Function func(isSgFunctionDeclaration(target->get_SgNode()));
        dbg << func.str()<<endl;
      } else
        dbg << "NULL"<<endl;
    }*/
  } else
    finished = true;
}

// Returns a reference to CGFunction that matches the current SgGraphNode that this iterator refers to,
// pulling the reference from the given set of CGFunctions
const CGFunction* CGFunction::iterator::getTarget(std::set<CGFunction> &functions)
{
  //printf("getTarget finished=%d\n", finished);
  SgGraphNode* target = (dir == fw ? (*ite)->get_to() : (*ite)->get_from());
  assert(isSgFunctionDeclaration(target->get_SgNode()));
  
  //dbg << "isSgFunctionDeclaration(target->get_SgNode())->get_file_info()->isCompilerGenerated()="<<isSgFunctionDeclaration(target->get_SgNode())->get_file_info()->isCompilerGenerated()<<endl;

  // GB 2013-03-13: Now including these functions in the CG. Not clear if there will be any issues associated with this decision
  // Compiler-generated functions do not appear as nodes in the call graph
  //if(isSgFunctionDeclaration(target->get_SgNode())->get_file_info()->isCompilerGenerated()) return NULL;

  // Find the CGFunction in functions that matches the target SgGraphNode
  for(std::set<CGFunction>::const_iterator it = functions.begin(); it!=functions.end(); it++)
  {
    //printf("    iteration. current: %s isCompilerGenerated=%d, target=%s, isCompilerGenerated=%d\n", (*it).get_name().str(), (*it).get_declaration()->get_file_info()->isCompilerGenerated(), target->functionDeclaration->get_name().str(), target->functionDeclaration->get_file_info()->isCompilerGenerated());
    // If the target SgGraphNode can be found in the current CGFunction
    if((&(*it))->cgNodes.find(target) != (&(*it))->cgNodes.end())
      return &(*it);
  }

  //dbg << "getTarget returning NULL since couldn't find target function"<<endl;

  // If we can't find it, return NULL
  assert(!"Error finding the target function of a call graph edge when the target is not compiler generated!");
  return NULL;
}

// Returns the function that this iterator is currently referring to
Function CGFunction::iterator::getTarget()
{
  SgGraphNode* target = (dir == fw ? (*ite)->get_to() : (*ite)->get_from());
  assert(isSgFunctionDeclaration(target->get_SgNode()));
  Function result(isSgFunctionDeclaration(target->get_SgNode()));
  return result;
}

void CGFunction::iterator::operator ++( int )
{
  if(!finished) {
    ite++;

    advanceToNextValidPoint();
  }
}

// If the current <itn, ite> pair refers to a specific CallGraph node, does nothing.
// otherwise, advances the <itn, ite> pair until it does refer to a specific CallGraph node
void CGFunction::iterator::advanceToNextValidPoint()
{
  //dbg << "Function::iterator::advanceToNextValidPoint() #edges="<<edges.size()<<" last edge="<<(ite == edges.end())<<endl;
  // Loop for as long as ite is not pointing to a valid node and hasn't reached the end of the node list
  while(!finished && itn != func->cgNodes.end())
  {
    // If ite is the last incoming/outgoing edge of the current SgGraphNode
    if(ite == edges.end())
    {
      /*dbg << "Function::iterator::advanceToNextValidPoint() while(), last="<<(itn == func->cgNodes.end())<<endl;
      indent ind;*/
      // Advance to the next SgGraphNode in cgNodes and keep walking through the cgNodes until we find one that has edges
      itn++;
      while(itn != func->cgNodes.end()) {
        if(dir == fw) edges = func->graph->computeEdgeSetOut(*itn);
        else          edges = func->graph->computeEdgeSetIn(*itn);

        if(edges.size()>0) break;
        itn++;
      }
      
      // If the current cgNode has edges, set ite to the first one
      if(itn != func->cgNodes.end()) {
        ite = edges.begin();

        /*dbg << "edges="<<endl;
        indent(1,1);
        for(set<SgDirectedGraphEdge*>::iterator e=edges.begin(); e!=edges.end(); e++) {
          SgGraphNode* target = (dir == fw ? (*e)->get_to() : (*e)->get_from());
          if(target) {
            Function func(isSgFunctionDeclaration(target->get_SgNode()));
            dbg << func.str()<<endl;
          } else
            dbg << "NULL"<<endl;
        }*/
      } else
        finished = true;
      return;
    }
    // Else, if it is not the last edges
    else
    {
      SgGraphNode* target = (dir == fw ? (*ite)->get_to() : (*ite)->get_from());
      
        /*{
          SgGraphNode* target = (dir == fw ? (*ite)->get_to() : (*ite)->get_from());
          if(target) {
            Function func(isSgFunctionDeclaration(target->get_SgNode()));
            dbg << "    advancing within CG Node target="<<func.str()<<", visited="<<(visitedCGNodes.find(target) != visitedCGNodes.end())<<endl;
          } else
            dbg << "    advancing within CG Node target=NULL"<<", visited="<<(visitedCGNodes.find(target) != visitedCGNodes.end())<<endl;
        }*/

      // If we've already seen this node
      if(visitedCGNodes.find(target) != visitedCGNodes.end()) {
        // Advance to the next node
        ite++;
        advanceToNextValidPoint();
      // Else, we have a valid node. Record that we've visited it and break out since we've found a valid upstream/downstream node
      } else {
        visitedCGNodes.insert(target);
        break;
      }
    }
  }
}

bool CGFunction::iterator::operator == (const iterator& that)
{
  // if either iterators are finished, then they're equal iff the other is finished, ignoring any other fields
  if(finished) return that.finished;
  else if(that.finished) return finished;

  // otherwise, they're equal only if all their other members are equal
  return (dir == that.dir) &&
         (itn == that.itn) &&
         (edges == that.edges) &&
         (ite == that.ite) &&
         (func == that.func);
}

bool CGFunction::iterator::operator != (const iterator& that)
{ return !((*this) == that); }

// Returns an iterator that traverses the callees of this function
CGFunction::iterator CGFunction::callees() const
{
  iterator b(this, iterator::fw);
  return b;
}
CGFunction::iterator CGFunction::successors() const
{
  iterator b(this, iterator::fw);
  return b;
}

// Returns an iterator that traverses all the callers of this function
CGFunction::iterator CGFunction::callers() const
{
  iterator b(this, iterator::bw);
  return b;
}
CGFunction::iterator CGFunction::predecessors() const
{
  iterator b(this, iterator::bw);
  return b;
}

CGFunction::iterator CGFunction::end() const
{
  iterator b;
  return b;
}


/*************************************
 ********* TraverseCallGraph *********
 *************************************/
 
  #include <sys/time.h>
 
TraverseCallGraph::TraverseCallGraph(SgIncidenceDirectedGraph* graph)
{
  this->graph = graph;
  
/*      struct timeval itv;
  struct timezone itz;
  struct timeval stv;
  struct timezone stz;
  struct timeval ntv;
  struct timezone ntz;
  
  gettimeofday(&itv, &itz);
  gettimeofday(&stv, &stz);*/
  
//printf("TraverseCallGraph::TraverseCallGraph\n");
  set<SgGraphNode *> nodes = graph->computeNodeSet();
  for(set<SgGraphNode*>::iterator itn = nodes.begin(); itn != nodes.end(); itn++) {
    SgNode* n = (*itn)->get_SgNode();
    assert(isSgFunctionDeclaration(n));
    
    //gettimeofday(&ntv, &ntz); printf("0 time = %lf secs, elapsed = %lf secs\n", (ntv.tv_sec + 1000000*ntv.tv_usec) - (stv.tv_sec + 1000000*stv.tv_usec), (ntv.tv_sec + 1000000*ntv.tv_usec) - (itv.tv_sec + 1000000*itv.tv_usec)); stv.tv_sec = ntv.tv_sec; stv.tv_usec = ntv.tv_usec; 
    CGFunction func(isSgFunctionDeclaration(n), graph);
    //gettimeofday(&ntv, &ntz); printf("1 time = %lf secs, elapsed = %lf secs\n", (ntv.tv_sec + 1000000*ntv.tv_usec) - (stv.tv_sec + 1000000*stv.tv_usec), (ntv.tv_sec + 1000000*ntv.tv_usec) - (itv.tv_sec + 1000000*itv.tv_usec)); stv.tv_sec = ntv.tv_sec; stv.tv_usec = ntv.tv_usec; 
    
    //printf("curFunction = %s\n", (*itn)->functionDeclaration->get_name().str());
    
    // GB 2013-03-13: Now including these functions in the CG. Not clear if there will be any issues associated with this decision
    // if this function is not compiler-generated
    //if(!func.get_file_info()->isCompilerGenerated())
    {
      // add the mapping to decl2CFNode
      //decl2CFNode[func].insert(*itn);
      /*printf("TraverseCallGraph::TraverseCallGraph inserting %s\n", func.get_name().str());
      printf("TraverseCallGraph::TraverseCallGraph functions.find(func) == functions.end() = %d\n", functions.find(func) == functions.end());*/
      
      functions.insert(func);
    }
    
    //gettimeofday(&ntv, &ntz); printf("2 time = %lf secs, elapsed = %lf secs\n", (ntv.tv_sec + 1000000*ntv.tv_usec) - (stv.tv_sec + 1000000*stv.tv_usec), (ntv.tv_sec + 1000000*ntv.tv_usec) - (itv.tv_sec + 1000000*itv.tv_usec)); stv.tv_sec = ntv.tv_sec; stv.tv_usec = ntv.tv_usec; 
  }
  //gettimeofday(&ntv, &ntz); printf("A time = %lf secs, elapsed = %lf secs\n", (ntv.tv_sec + 1000000*ntv.tv_usec) - (stv.tv_sec + 1000000*stv.tv_usec), (ntv.tv_sec + 1000000*ntv.tv_usec) - (itv.tv_sec + 1000000*itv.tv_usec)); stv.tv_sec = ntv.tv_sec; stv.tv_usec = ntv.tv_usec; 
  
  // initially, put all the nodes into noPred
  // initialized numCallers
  /*for(map<SgFunctionDefinition*, set<SgGraphNode*> >::iterator it = decl2CFNode.begin(); 
      it!=decl2CFNode.end(); it++)*/
  for(set<CGFunction>::iterator it = functions.begin(); it != functions.end(); it++)
  {
    noPred.insert((&*it));
    //numCallers[it->first] = 0;
    numCallers[(&*it)] = 0;
    //printf("noPred: %s\n", it->first->get_declaration()->get_name().str());
  }
  
  //gettimeofday(&ntv, &ntz); printf("B time = %lf secs, elapsed = %lf secs\n", (ntv.tv_sec + 1000000*ntv.tv_usec) - (stv.tv_sec + 1000000*stv.tv_usec), (ntv.tv_sec + 1000000*ntv.tv_usec) - (itv.tv_sec + 1000000*itv.tv_usec)); stv.tv_sec = ntv.tv_sec; stv.tv_usec = ntv.tv_usec; 
  // next, toss out all the nodes that have predecessor nodes
  // and compute the correct numCallers mapping
  
  // set of edges that have been visited by the traversal
  set<pair<const CGFunction*, const CGFunction*> > touchedEdges;
  /*for(map<SgFunctionDefinition*, set<SgGraphNode*> >::iterator it = decl2CFNode.begin(); 
      it!=decl2CFNode.end(); it++)*/
  for(set<CGFunction>::iterator func = functions.begin(); func != functions.end(); func++)
  {
    //printf("curFunction = %s\n", (*func).get_name().str());
    for(CGFunction::iterator it = (*func).successors(); it != (*func).end(); it++)
    {
      const CGFunction* target = it.getTarget(functions);
      
      // if the target is compiler-generated, skip it
      if(target==NULL) continue;
      
      // if we haven't yet touched this edge  
      pair<const CGFunction*, const CGFunction*> edge(&(*func), target);
      if(touchedEdges.find(edge) == touchedEdges.end())
      {
        // increment the target function's number of callers
        numCallers[target]++;
        //printf("       numCallers[%s]=%d\n", tgtDecl->get_name().str(), numCallers[tgtDecl]);
        
        // if the given callee is currently in noPred
        set<const CGFunction*>::iterator pred_it = noPred.find(target);
        //printf("    pred_it == noPred.end() = %d\n", pred_it == noPred.end());
        if(pred_it != noPred.end())
          // remove it
          noPred.erase(target);
      }
      
      // add this edge to touchedEdges
      touchedEdges.insert(edge);
    }
    //gettimeofday(&ntv, &ntz); printf("C time = %lf secs, elapsed = %lf secs\n", (ntv.tv_sec + 1000000*ntv.tv_usec) - (stv.tv_sec + 1000000*stv.tv_usec), (ntv.tv_sec + 1000000*ntv.tv_usec) - (itv.tv_sec + 1000000*itv.tv_usec)); stv.tv_sec = ntv.tv_sec; stv.tv_usec = ntv.tv_usec; 
  }
  //gettimeofday(&ntv, &ntz); printf("D time = %lf secs, elapsed = %lf secs\n", (ntv.tv_sec + 1000000*ntv.tv_usec) - (stv.tv_sec + 1000000*stv.tv_usec), (ntv.tv_sec + 1000000*ntv.tv_usec) - (itv.tv_sec + 1000000*itv.tv_usec)); stv.tv_sec = ntv.tv_sec; stv.tv_usec = ntv.tv_usec; 
}

// returns a pointer to a CGFunction that matches the given declaration or NULL if no objects do
// the memory of the object persists for the entire lifetime of this TraverseCallGraph object
const CGFunction* TraverseCallGraph::getFunc(SgFunctionDeclaration* decl)
{
  CGFunction func(decl, graph);
  
  set<CGFunction>::iterator findLoc = functions.find(func);
  if(findLoc == functions.end())
    return NULL;
  
  return &(*findLoc);
}

// returns a pointer to a CGFunction object that matches the given Function object
// the memory of the object persists for the entire lifetime of this TraverseCallGraph object
const CGFunction* TraverseCallGraph::getFunc(const Function& func)
{
  return getFunc(func.get_declaration());
}

/************************************
 ***** TraverseCallGraphUnordered *****
 ************************************/

TraverseCallGraphUnordered::TraverseCallGraphUnordered(SgIncidenceDirectedGraph* graph): 
  TraverseCallGraph(graph)
{}

void TraverseCallGraphUnordered::traverse()
{
  for(set<CGFunction>::iterator f=functions.begin(); f!=functions.end(); f++) {
    visit(&(*f));
  }
}

TraverseCallGraphUnordered::~TraverseCallGraphUnordered() {}

/************************************
 ***** TraverseCallGraphTopDown *****
 ************************************/

template <class InheritedAttribute>
TraverseCallGraphTopDown<InheritedAttribute>::TraverseCallGraphTopDown(SgIncidenceDirectedGraph* graph): 
  TraverseCallGraph(graph)
{}

template <class InheritedAttribute>
void TraverseCallGraphTopDown<InheritedAttribute>::traverse()
{
  map<const CGFunction*, funcRecord> visitRecords;
  // set of edges that have been visited by the traversal
  set<pair<const CGFunction*, const CGFunction*> > touchedEdges;
  
  //printf("traverse: noPred.size()=%d\n", noPred.size());
  
  // start the traversal from the nodes that are called from no other node
  for(set<const CGFunction*>::iterator it = noPred.begin(); it!=noPred.end(); it++)
  {
    //printf("  *it=0x%x\n", *it);
    
    // create a default attribute
    InheritedAttribute funcAttr = defaultAttrVal();
    //printf("TraverseCallGraphTopDown::traverse() funcDecl=%s\n", (*it)->get_declaration()->get_name().str());
    traverse_rec(*it, visitRecords, touchedEdges, funcAttr);
  }
}

template <class InheritedAttribute>
void TraverseCallGraphTopDown<InheritedAttribute>::traverse_rec(const CGFunction* fd, 
             map<const CGFunction*, funcRecord> &visitRecords, 
             set<pair<const CGFunction*, const CGFunction*> > &touchedEdges,
             InheritedAttribute &fromCaller)
{
  /*printf("traverse_rec: func: 0x%x\n", fd);
  printf("traverse_rec: func->get_declaration(): 0x%x\n", fd->get_declaration());
  printf("traverse_rec: func->get_definition(): 0x%x\n", fd->get_definition());*/
  
  //printf("traverse_rec: %s()\n", fd->get_name().str());


  // add the caller's attribute to its list of inherited attributes
  visitRecords[fd].fromCallers.push_back(fromCaller);
  
  /*printf("        visitRecords[fd].fromCallers.size()=%d\n", visitRecords[fd].fromCallers.size());
  printf("        numCallers[fd]=%d\n", numCallers[fd]);*/
  
  // if we've added all of this function's inherited attributes to its record
  if(visitRecords[fd].fromCallers.size()>=(unsigned int)numCallers[fd])
  {
    // call visit the current function
    InheritedAttribute results = visit(fd, visitRecords[fd].fromCallers);
  
    //printf("SgGraphNode: %s\n", fd->get_declaration()->unparseToString().c_str());
    // Pass the visit function's output to its callees
    for(CGFunction::iterator it = fd->successors(); it != fd->end(); it++)
    {
      const CGFunction* target = it.getTarget(functions);
      
      // if the target is compiler-generated, skip it
      if(target==NULL) continue;
      
      // if we haven't yet touched this edge  
      pair<const CGFunction*, const CGFunction*> edge(fd, target);
      if(touchedEdges.find(edge) == touchedEdges.end())
      {
        /*printf("    calls: target = 0x%x\n", target);
        printf("    calls: target->get_declaration() = 0x%x\n", target->get_declaration());
        printf("    calls: target->get_definition() = 0x%x\n", target->get_definition());
        printf("    calls: unparse = %s\n", target->get_declaration()->unparseToString().c_str());*/
        //printf("    calls: target %s\n", target->get_name().str());
        // recurse down this edge
        traverse_rec(target, visitRecords, touchedEdges, results);
        //printf("    |---------|\n");
      }
      
      //printf("adding edge from %s to %s\n", fd->get_name().str(), tgtFuncDecl->get_name().str());
      // add this edge to touchedEdges
      touchedEdges.insert(edge);
    }
  }
}

template <class InheritedAttribute>
TraverseCallGraphTopDown<InheritedAttribute>::~TraverseCallGraphTopDown() {}

/*************************************
 ***** TraverseCallGraphBottomUp *****
 *************************************/

template <class SynthesizedAttribute>
TraverseCallGraphBottomUp<SynthesizedAttribute>::TraverseCallGraphBottomUp(SgIncidenceDirectedGraph* graph): 
  TraverseCallGraph(graph)
{}

template <class SynthesizedAttribute>
void TraverseCallGraphBottomUp<SynthesizedAttribute>::traverse()
{
  map<const CGFunction*, SynthesizedAttribute> visitRecords;
  // set of edges that have been visited by the traversal
  set<pair<const CGFunction*, const CGFunction*> > touchedEdges;
  
  // start the traversal from the nodes that are called from no other node
  for(set<const CGFunction*>::iterator it = noPred.begin(); it!=noPred.end(); it++)
  {
    //printf("  *it=0x%x\n", *it);
    
    //printf("TraverseCallGraphTopDown::traverse() funcDecl=%s\n", (*it)->get_name().str());
    traverse_rec(*it, visitRecords, touchedEdges);
  }
}

template <class SynthesizedAttribute>
SynthesizedAttribute TraverseCallGraphBottomUp<SynthesizedAttribute>::traverse_rec(
             const CGFunction* fd, 
              map<const CGFunction*, SynthesizedAttribute> &visitRecords, 
              set<pair<const CGFunction*, const CGFunction*> > &touchedEdges)
{
  // list of attributes from this function's callees
  list <SynthesizedAttribute> fromCallees;
  
  //printf("traverse_rec::function: %s\n", fd->get_name().str());
  //printf("<<<\n");
  // traverse over the callees and compute the list of their synthesized attributes (fromCallees)
  for(CGFunction::iterator it = fd->successors(); it != fd->end(); it++)
  {
    const CGFunction* target = it.getTarget(functions);
      
    // if the target is compiler-generated, skip it
    if(target==NULL) continue;
    //printf("    calls: %s\n", tgtFuncDecl->get_name().str());
    
    // if we haven't yet called this function before
    pair<const CGFunction*, const CGFunction*> edge(fd, target);
    if(visitRecords.find(target) == visitRecords.end())
    {
      //printf("  new edge/function\n");
      // recurse down to this function, storing its result in visitRecords
      traverse_rec(target, visitRecords, touchedEdges);
    }
    
    // if we haven't yet touched this edge
    if(touchedEdges.find(edge) == touchedEdges.end())
    {
      // add the current callee's synthesized attribute into the list for the current function
      fromCallees.push_back(visitRecords[target]);
      
      //printf("   adding edge from %s to %s\n", fd->get_name().str(), tgtFuncDecl->get_name().str());
      if(touchedEdges.find(edge) == touchedEdges.end())
        // add this edge to touchedEdges
        touchedEdges.insert(edge);
    }
  }
  
  // if this function has no callees, fill fromCallees with just a single default instance of SynthesizedAttribute
  if(fromCallees.size()==0)
  {
    SynthesizedAttribute deft = defaultAttrVal();
    fromCallees.push_back(deft);
  }
  
  SynthesizedAttribute res = visit(fd, fromCallees);
  // add the current function's result to the visitRecords for use by this function's callers
  visitRecords[fd] = res;
  //printf(">>>\n");
  
  return res;
}

template <class SynthesizedAttribute>
TraverseCallGraphBottomUp<SynthesizedAttribute>::~TraverseCallGraphBottomUp() {}

//}

/*************************************
 ***** TraverseCallGraphDataflow *****
 *************************************/
TraverseCallGraphDataflow::TraverseCallGraphDataflow(SgIncidenceDirectedGraph* graph): TraverseCallGraph(graph)
{}

void TraverseCallGraphDataflow::traverse()
{
  // start the traversal from the nodes that are called from no other node
  for(set<const CGFunction*>::iterator it=noPred.begin(); it!=noPred.end(); it++)
    remaining.push_back(*it);
  
  // traverse functions for as long as visit keeps adding them to remaining
  while(remaining.size()>0)
  {
    const CGFunction* func = remaining.front();
    remaining.pop_front();
    visit(func);
  }
}

// adds func to the back of the remaining list, if its not already there
void TraverseCallGraphDataflow::addToRemaining(const CGFunction* func)
{
  for(list<const CGFunction*>::iterator it = remaining.begin(); it!=remaining.end(); it++)
    // if this function is already in remaining, don't bother inserting it
    if(*it == func)
      return;

  // insert func, if it was not found
  remaining.push_back(func);
}

TraverseCallGraphDataflow::~TraverseCallGraphDataflow() {}

/*********************************************************
 ***         numCallersAnnotator     ***
 *** Annotates every function's SgFunctionDefinition   ***
 *** node with a numCallersAttribute that contains the ***
 *** number of functions that call the given function. ***
 *********************************************************/
class numCallersAnnotator_Int
{
  public:
  int val;
  
  numCallersAnnotator_Int()
  {
    val=0;
  }
  
  numCallersAnnotator_Int(int val)
  {
    this->val=val;
  }
};

class numCallersAnnotator : public virtual TraverseCallGraphTopDown<numCallersAnnotator_Int>
{
  public:
  numCallersAnnotator(SgIncidenceDirectedGraph* graph) : TraverseCallGraphTopDown<numCallersAnnotator_Int>(graph)
  {}
  
  numCallersAnnotator_Int visit(const CGFunction* func, list<numCallersAnnotator_Int>& fromCallers)
  {
    //printf("visit: fromCallers.size()=%d\n", fromCallers.size());
    
    int totalCallers=0;
    for(list<numCallersAnnotator_Int>::iterator it = fromCallers.begin(); it!=fromCallers.end(); it++)
    {
      totalCallers+=(*it).val;
    }
    //printf("annotating %s / 0x%x\n", func->get_name().str(), func->get_declaration());
    func->get_declaration()->addNewAttribute("numCallers", new numCallersAttribute(totalCallers));
    
    numCallersAnnotator_Int retInt(1);
    return retInt;
  }
};

// = true if annotateNumCallers() has been called and =false otherwise
static bool calledAnnotateNumCallers = false;

// annotates every fucntion's SgFunctionDefinition node with a numCallersAttribute that contains
// the number of functions that call the given function
void annotateNumCallers(SgIncidenceDirectedGraph* graph)
{
  numCallersAnnotator nca(graph);
  nca.traverse();
  calledAnnotateNumCallers = true;
}

// returns the number of functions that call this function or 0 if the function is compiler-generated
int getNumCallers(const Function* func)
{
  assert(calledAnnotateNumCallers);
  
  if(func->get_declaration()->get_file_info()->isCompilerGenerated()) return 0;
  //printf("looking up numCallers of func=0x%x=%s()\n", func, func->get_declaration()->get_name().str());
  
  //printf("looking up %s / 0x%x\n", func->get_name().str(), func->get_declaration());
  
  return ((numCallersAttribute*)func->get_declaration()->getAttribute("numCallers"))->getNumCallers();
}
} // namespace fuse
#endif
